### Modern javascript for Django developers
Courtesy of [SaaS Pegasus](https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/)

#### Part 1 of 6

- Summary:<br>
Two structures of organizing frontend in a django project.
backend first and client first.
this guide will going to introduce a hybrid architecture with benefits of both worlds.

full js frameworks: react, vue, svelte
low-javascript frameworks: Alpine.js HTMX

The server first (backend first) architecture will become to complex and messy very quickly.<br>
The client first framework: frontend is separate from backend. backend is mostly django-rest-framework API into database. They use a combination of Node.js and Django to serve the app.<br>

Tradeoffs:<br>
Django's built-in support for templates, forms, other front-end goodies are out.<br>
They require much work for simple tasks.<br>

In hybrid architecture, rather than choosing between client first or server first at the project level, we choose it at page level.


#### Part 2 of 6
Modern Javascript tooling<br>

- The modern javascript toolchain:<br>
It consists of mainly three parts:
1. A package manager (allows us to import and use packages other people have built, similar to pip)
2. A compiler (also called transpiler, they take js code and make it backward compatible for old brwsers, Babel is most popular, SWC and esbuild are stepping up)
3. A bundler (often combined with compiler as one whole 'building' step. they take all the libraries and any code you've written and bundle it up. they mash it together into one or very few files, so they can be dropped in site easier.)

Bundlers commonly bundle js, but later they can be used to optimize and bundle css files as well.<br>
Webpack and Vite are the top.<br>
Babel is managed by webpack.
esbuild is managed by vite.


#### Part 3 of 6
- Part 3 has two versions: Webpack and Vite
Wepback is important for legacy projects.
Vite for almost all new projects.

(Here i started actually writing the project. the vite one.)
(Later i may add the webpack.)
(In this tutorial the bundled files will be placed in the 'static' folder and actual usable frontend files will be assets folder. exactly as opposed to the previous tutorials i went through.)

1. First we create a django project.

2. Then we'll create a folder in project root dir. This folder is where we'll do our frontend development.
we'll call it assets/ here. 
Django will only works with outputs generated by the bundler.
So it addition to assets/ folder, we'll also dump the outputs somewhere that django's static file system can find.
The default is a folder in project root, named static/.
(So i added this file to gitignore)

so here is the basic frontend flow assets -> bundle up -> static

For the beginning, the entire front-end code will be bundled in one large file called index-bundle.js

3. Initialize a new npm project in django root dir
```
> npm init -y
> npm install -D vite
```

4. Add index.js file to assets/
This file will create a div component and add it to the body of our template (probably _base.html)

5. Add vite.config.js to root/ (root/ is backend folder)

6. Add a npm script to run vite, to package.json<br>
7. run 'npm run build' to check if build works ok<br>
You should see a index-bundle.js in static/js/<br>

8. Now we need to link the bundled file to our django template (standard django, make sure you're properly serving template and static files)<br>
(i will add it to _base.html, and add an index.html and render it)<br>
(also i added STATICFILES_DIRS to settings, without it, index-bundle.js may not be served)<br>
now run the django dev server to see if the 'hello vite' message appears.<br>

- Adding hot module replacement (HMR) with django-vite<br>
(This is so that we don't have to run npm run build everytime we make a change.)

- Vite in addition to being a bundler, is also a server with HMR built into it.<br>
The problem is that in order to use HMR, we need to serve our assets using vite's server.
This is where django-vite comes in. It gives us {% vite_asset %} to load js files. <br>
And provides {% vite_hmr_client %} to add HMR.<br>

It works like this: if we're in dev mode (debug is on), serve file from vite, otherwise serve the built version.

9. Now update base.html by replacing load static with load django_vite and static link to js bundle by vite_asset directive.
Also add vite hmr client tag to head
(the vite_asset directive points direclty to assets/index.js not the bundle file)
(if dev_mode is off, django_vite will detect it and use manifest.json to load the bundle js file instead of source js file)

We also need to install django_vite and update the settings (add to apps, add its config var DJANGO_VITE)
```
> pip install django-vite
```

10. Add another npm comamnd for running the vite dev server
Turn on the vite dev server in one terminal (will serve static files only)
and django dev server in another terminal. visist index page, and change something in index.js file to check the HMR.
(Also django_vite was throwing errors, apparently required STATIC_ROOT)
(STATIC_ROOT cannot be equal to STATICFILES_DIRS so i set it to statc/dist)
(STATIC_ROOT will be where collectstatic command will dump the output static files, not sure how it is used here)


- How to add other js libraries?
11. We're going to try adding the lodash library (utility for common programming tasks) as an example.
```
> npm install lodash
```
Note: For packages that will be used in dev stage (such as linters, testing libraries), you should include --save-dev or -D to install as development dependency. Tooling will often remove these packages for production to reduce the load.

12. The import it in source index.js file
(this process must be followed for other packages as well. npm install and then load in source index.js)


- Setting up React
13. Install React
```
> npm install -D @vitejs/plugin-react
```

14. Add (react's plugin) it to vite.config.js

15. Then install React and ReactDOM

16. Create a simple react component
(Using a .jsx extension automatically tells Vite to load our JSX parser, so we can use JSX syntax in our code. )
(I'm putting this inside assets/)

17. Update vite.config.js by adding a new entry point

18. Update _base.html (hello.jsx will inject react code into a div with the id of root)
(also update the vite_asset to point to hello.jsx) ?(this will remove index.js from our code, but why?)


- Adding TailwindCSS
19. Install the tailwind vite plugin
```
> npm install -D @tailwindcss/vite
```

20. Add the plugin to vite.config.js

21. Then install tailwind itself
```
> npm install tailwindcss
```

22. Create a base css file in assets/style.css and add tailwind import to it
(don't know why we're not using assets/js and assets/stylesheets folders)

23. Update vite.config.js by adding another asset input and output

24. Add vite_assest directive to head of base template

25. Add some tailwind utility code to hello.jsx and maybe _base.html


- Building React pages for Django App
We will develop a CRUD app where any user can signup and manage their own employees

Breaking down the architecture:
We'll be using normal django views, each view will render a normal django template.
These templates will be just a skeleton for for compiled react components.
React components will be created and managed separately and injected into django templates.

IMPORTANT:
Since we're serving react pages directly from django, there is no need for handling of CORS and 3rd-party authentication frameworks

VERY IMPORTANT:
the vite_asset template directive must point to assets (entry files)
django_vite will automatically decide which files to server, entry assets or build files by checking DEBUG and manifest.json

ERROR:
"@vitejs/plugin-react can't detect preamble. Something is wrong."
RESULT: I was able to fix this by a script tag that will directly import it from vite server (added to base html)
```
<script type="module">
    import RefreshRuntime from 'http://localhost:5173/static/@react-refresh'
    RefreshRuntime.injectIntoGlobalHook(window)
    window.$RefreshReg$ = () => {}
    window.$RefreshSig$ = () => (type) => type
    window.__vite_plugin_react_preamble_installed__ = true
</script>
```

(Part 4 and 5 skipped for now)

#### Part 6 of 6
Benefits of using API Standards:
1. They make it easy to document yor API
2. They provide tooling that let others explore and test against your APIs
3. They help automatically generate API Code for you

OpenAPI Specification (OAS)<br>
Defines a standard, language agnostic interface to HTTP APIs which allows both humans and computers
to discover, understand, and interact with the API.<br>

- An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.<br>

1. We'll use a package called drf-spectacular to add OpenAPI standard to our project<br>
```
> pip install drf-spectacular
```

2. Add the settings (and some metadata, optional but recommended by drf-spectacular)

IMPORTANT
- Some have may have limited to access to internet and as such are unable to retrieve the necessary UI files for Swagger and Redoc.<br>
drf-spectacular provides these files as static files as a separate optional package, called drf-spectacular-sidecar:
```
> pip install drf-spectacular[sidecar]
```
- Settings:
```
INSTALLED_APPS = [
    # ALL YOUR APPS
    'drf_spectacular',
    'drf_spectacular_sidecar',  # required for Django collectstatic discovery
]
SPECTACULAR_SETTINGS = {
    'SWAGGER_UI_DIST': 'SIDECAR',  # shorthand to use the sidecar instead
    'SWAGGER_UI_FAVICON_HREF': 'SIDECAR',
    'REDOC_DIST': 'SIDECAR',
    # OTHER SETTINGS
}
```

3. Generate OpenAPI schema file:
```
> python manage.py spectacular --file schema.yml
```

4. Add a url to expose the API schema to root urls.py

5. Add urls to include Redoc and Swagger UI tools to automatically generate documentaiton

- Creating API Clients using OpenAPI Generator
```
> npm install @openapitools/openapi-generator-cli -g
```
(-g is for globally, installs the package globally on your system)

(java is required)
(i installed java using scoop, but it installed a very old version of it)
(minimum version for openapi-generator-cli as of writing this, is 17)
(then i heard about something called adoptium and temurin)
(apparently temurin is a free distribution of java)

- to check your java version:
```
> java -version
```

6. After installing required java version (this uses typescript, tutorial uses this):
```
> openapi-generator-cli generate -i schema.yml -g typescript-fetch -o ./assets/src/api/
```

7. (This is javascript version)
```
> openapi-generator-cli generate -i schema.yml -g javascript -o ./assets/src/api/
```

- the -i flag, tells it where to find the schema.yml file
- the -g typescript-fetch tells it to genereate client for typescript and fetch library (which i changed to javascript)
- the -o flag tells it where to save the client files

8. drf-spectacular only recognizes api views
(views that have a serializer, or inherit from api classes from rest_framework)
(or api_view decorator from rest_framework)
(i was able to include the login view using the api_view decorator, sort of)

9. Handling urls
Handling URLS in hybrid applications is extremely complicated
Tutorial suggests using React Router<br>
React Router has three modes: Framework, Data, Declarative
```
> npm i react-router
```
(crap, everything is ts)
(attempting to use react-router-dom)
```
> npm install react-router-dom
```

