### Modern javascript for Django developers
Courtesy of [SaaS Pegasus](https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/)

#### Part 1 of 6

- Summary:<br>
Two structures of organizing frontend in a django project.
backend first and client first.
this guide will going to introduce a hybrid architecture with benefits of both worlds.

full js frameworks: react, vue, svelte
low-javascript frameworks: Alpine.js HTMX

The server first (backend first) architecture will become to complex and messy very quickly.<br>
The client first framework: frontend is separate from backend. backend is mostly django-rest-framework API into database. They use a combination of Node.js and Django to serve the app.<br>

Tradeoffs:<br>
Django's built-in support for templates, forms, other front-end goodies are out.<br>
They require much work for simple tasks.<br>

In hybrid architecture, rather than choosing between client first or server first at the project level, we choose it at page level.


#### Part 2 of 6
Modern Javascript tooling<br>

- The modern javascript toolchain:<br>
It consists of mainly three parts:
1. A package manager (allows us to import and use packages other people have built, similar to pip)
2. A compiler (also called transpiler, they take js code and make it backward compatible for old brwsers, Babel is most popular, SWC and esbuild are stepping up)
3. A bundler (often combined with compiler as one whole 'building' step. they take all the libraries and any code you've written and bundle it up. they mash it together into one or very few files, so they can be dropped in site easier.)

Bundlers commonly bundle js, but later they can be used to optimize and bundle css files as well.<br>
Webpack and Vite are the top.<br>
Babel is managed by webpack.
esbuild is managed by vite.


#### Part 3 of 6
- Part 3 has two versions: Webpack and Vite
Wepback is important for legacy projects.
Vite for almost all new projects.

(Here i started actually writing the project. the vite one.)
(Later i may add the webpack.)
(In this tutorial the bundled files will be placed in the 'static' folder and actual usable frontend files will be assets folder. exactly as opposed to the previous tutorials i went through.)

1. First we create a django project.

2. Then we'll create a folder in project root dir. This folder is where we'll do our frontend development.
we'll call it assets/ here. 
Django will only works with outputs generated by the bundler.
So it addition to assets/ folder, we'll also dump the outputs somewhere that django's static file system can find.
The default is a folder in project root, named static/.
(So i added this file to gitignore)

so here is the basic frontend flow assets -> bundle up -> static

For the beginning, the entire front-end code will be bundled in one large file called index-bundle.js

3. Initialize a new npm project in django root dir
```
> npm init -y
> npm install -D vite
```

4. Add index.js file to assets/
This file will create a div component and add it to the body of our template (probably _base.html)

5. Add vite.config.js to root/ (root/ is backend folder)

6. Add a npm script to run vite, to package.json<br>
7. run 'npm run build' to check if build works ok<br>
You should see a index-bundle.js in static/js/<br>

8. Now we need to link the bundled file to our django template (standard django, make sure you're properly serving template and static files)<br>
(i will add it to _base.html, and add an index.html and render it)<br>
(also i added STATICFILES_DIRS to settings, without it, index-bundle.js may not be served)<br>
now run the django dev server to see if the 'hello vite' message appears.<br>

- Adding hot module replacement (HMR) with django-vite<br>
(This is so that we don't have to run npm run build everytime we make a change.)

- Vite in addition to being a bundler, is also a server with HMR built into it.<br>
The problem is that in order to use HMR, we need to serve our assets using vite's server.
This is where django-vite comes in. It gives us {% vite_asset %} to load js files. <br>
And provides {% vite_hmr_client %} to add HMR.<br>

It works like this: if we're in dev mode (debug is on), serve file from vite, otherwise serve the built version.

9. Now update base.html by replacing load static with load django_vite and static link to js bundle by vite_asset directive.
Also add vite hmr client tag to head
(the vite_asset directive points direclty to assets/index.js not the bundle file)
(if dev_mode is off, django_vite will detect it and use manifest.json to load the bundle js file instead of source js file)

We also need to install django_vite and update the settings (add to apps, add its config var DJANGO_VITE)
```
> pip install django-vite
```

10. Add another npm comamnd for running the vite dev server
Turn on the vite dev server in one terminal (will serve static files only)
and django dev server in another terminal. visist index page, and change something in index.js file to check the HMR.
(Also django_vite was throwing errors, apparently required STATIC_ROOT)
(STATIC_ROOT cannot be equal to STATICFILES_DIRS so i set it to statc/dist)
(STATIC_ROOT will be where collectstatic command will dump the output static files, not sure how it is used here)


- How to add other js libraries?
11. We're going to try adding the lodash library (utility for common programming tasks) as an example.
```
> npm install lodash
```
Note: For packages that will be used in dev stage (such as linters, testing libraries), you should include --save-dev or -D to install as development dependency. Tooling will often remove these packages for production to reduce the load.

12. The import it in source index.js file
(this process must be followed for other packages as well. npm install and then load in source index.js)

